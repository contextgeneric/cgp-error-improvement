/// Module for building an internal database of diagnostics and merging related errors
/// This implements the approach described in Chapters 7-8 of the report
use cargo_metadata::diagnostic::{Diagnostic, DiagnosticLevel, DiagnosticSpan};
use cargo_metadata::{CompilerMessage, PackageId, Target};
use std::collections::HashMap;

use crate::cgp_diagnostic::CgpDiagnostic;
use crate::cgp_patterns::{
    ComponentInfo, FieldInfo, ProviderRelationship, extract_check_trait, extract_component_info,
    extract_field_info, extract_provider_relationship, has_other_hasfield_implementations,
};

/// A database that collects and merges related diagnostic information
#[derive(Debug, Default)]
pub struct DiagnosticDatabase {
    /// Map from diagnostic key to merged diagnostic entry
    entries: HashMap<DiagnosticKey, DiagnosticEntry>,
}

/// Key used to identify and group related diagnostics
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct DiagnosticKey {
    /// Primary source location (file:line:column)
    location: SourceLocation,
    /// Component involved (if any)
    component: Option<String>,
}

/// Source code location
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct SourceLocation {
    file: String,
    line: usize,
    column: usize,
}

impl SourceLocation {
    fn from_span(span: &DiagnosticSpan) -> Self {
        SourceLocation {
            file: span.file_name.clone(),
            line: span.line_start,
            column: span.column_start,
        }
    }
}

/// A merged diagnostic entry combining information from multiple related errors
#[derive(Debug, Clone)]
pub struct DiagnosticEntry {
    /// The original diagnostic (we keep the first one as the primary)
    pub original: Diagnostic,

    /// Package ID from the CompilerMessage
    pub package_id: PackageId,

    /// Target from the CompilerMessage
    pub target: Target,

    /// Extracted field information (missing field errors)
    pub field_info: Option<FieldInfo>,

    /// Component information
    pub component_info: Option<ComponentInfo>,

    /// Check trait name (from "required by a bound in")
    /// This is the trait generated by check_components!, not the actual consumer trait
    pub check_trait: Option<String>,

    /// Provider relationships extracted from error chain
    pub provider_relationships: Vec<ProviderRelationship>,

    /// Delegation chain notes (raw, for later processing)
    pub delegation_notes: Vec<String>,

    /// Whether this type has other HasField implementations
    pub has_other_hasfield_impls: bool,

    /// Primary span for error reporting
    pub primary_span: Option<DiagnosticSpan>,

    /// Error code (e.g., "E0277")
    pub error_code: Option<String>,

    /// Main error message
    pub message: String,

    /// Whether this is a root cause or a transitive error
    pub is_root_cause: bool,

    /// Whether this error should be suppressed (because it's redundant)
    pub suppressed: bool,
}

impl DiagnosticDatabase {
    pub fn new() -> Self {
        Self::default()
    }

    /// First pass: Add a compiler message to the database
    /// If a related diagnostic already exists, merge information
    pub fn add_diagnostic(&mut self, compiler_message: &CompilerMessage) {
        let diagnostic = &compiler_message.message;

        // Extract key components for grouping
        let primary_span = match diagnostic.spans.iter().find(|s| s.is_primary) {
            Some(span) => span,
            None => {
                // Can't process without a location
                return;
            }
        };

        let location = SourceLocation::from_span(primary_span);

        // Extract component info for grouping - try all children and notes
        let component_info = Self::extract_component_info_from_diagnostic(diagnostic);

        // Try to match by location first, even without component info
        // This handles cases where one error has component info and the other doesn't
        let mut matched_key = None;

        // If we have component info, try exact match first
        if let Some(ref comp_info) = component_info {
            let key_with_component = DiagnosticKey {
                location: location.clone(),
                component: Some(comp_info.component_type.clone()),
            };
            if self.entries.contains_key(&key_with_component) {
                matched_key = Some(key_with_component);
            }
        }

        // If no exact match, try to find any entry at the same location
        if matched_key.is_none() {
            for existing_key in self.entries.keys() {
                if existing_key.location == location {
                    matched_key = Some(existing_key.clone());
                    break;
                }
            }
        }

        if let Some(existing_key) = matched_key {
            // Merge new information into existing entry
            Self::merge_diagnostic_info(&mut self.entries, &existing_key, diagnostic);
        } else {
            // Create new entry with the component info we found
            let key = DiagnosticKey {
                location: location.clone(),
                component: component_info.as_ref().map(|c| c.component_type.clone()),
            };
            let entry = Self::create_entry(
                diagnostic,
                primary_span.clone(),
                compiler_message.package_id.clone(),
                compiler_message.target.clone(),
            );
            self.entries.insert(key, entry);
        }
    }

    /// Creates a new diagnostic entry from a diagnostic
    fn create_entry(
        diagnostic: &Diagnostic,
        primary_span: DiagnosticSpan,
        package_id: PackageId,
        target: Target,
    ) -> DiagnosticEntry {
        // Extract all available information
        let field_info = extract_field_info(diagnostic);
        let component_info = Self::extract_component_info_from_diagnostic(diagnostic);
        let check_trait = Self::extract_check_trait_from_diagnostic(diagnostic);
        let provider_relationships =
            Self::extract_provider_relationships_from_diagnostic(diagnostic);
        let delegation_notes = Self::extract_delegation_notes(diagnostic);
        let has_other_hasfield_impls = has_other_hasfield_implementations(diagnostic);
        let error_code = diagnostic.code.as_ref().map(|c| c.code.clone());

        // Determine if this is a root cause
        // A root cause has field_info (missing field) or is the most specific error
        let is_root_cause = field_info.is_some();

        DiagnosticEntry {
            original: diagnostic.clone(),
            package_id,
            target,
            field_info,
            component_info,
            check_trait,
            provider_relationships,
            delegation_notes,
            has_other_hasfield_impls,
            primary_span: Some(primary_span),
            error_code,
            message: diagnostic.message.clone(),
            is_root_cause,
            suppressed: false,
        }
    }

    /// Merges information from a new diagnostic into an existing entry
    fn merge_diagnostic_info(
        entries: &mut HashMap<DiagnosticKey, DiagnosticEntry>,
        key: &DiagnosticKey,
        new: &Diagnostic,
    ) {
        if let Some(existing) = entries.get_mut(key) {
            // If the new diagnostic has field info and existing doesn't, add it
            if existing.field_info.is_none() {
                if let Some(field_info) = extract_field_info(new) {
                    existing.field_info = Some(field_info);
                    existing.is_root_cause = true;
                }
            }

            // Merge component info
            if existing.component_info.is_none() {
                existing.component_info = Self::extract_component_info_from_diagnostic(new);
            }

            // Merge check trait
            if existing.check_trait.is_none() {
                existing.check_trait = Self::extract_check_trait_from_diagnostic(new);
            }

            // Add new provider relationships
            let new_relationships = Self::extract_provider_relationships_from_diagnostic(new);
            for rel in new_relationships {
                if !existing.provider_relationships.contains(&rel) {
                    existing.provider_relationships.push(rel);
                }
            }

            // Merge delegation notes
            let new_notes = Self::extract_delegation_notes(new);
            for note in new_notes {
                if !existing.delegation_notes.contains(&note) {
                    existing.delegation_notes.push(note);
                }
            }

            // Update hasfield implementations flag
            if !existing.has_other_hasfield_impls {
                existing.has_other_hasfield_impls = has_other_hasfield_implementations(new);
            }

            // If the new diagnostic has an error code and existing doesn't, use it
            if existing.error_code.is_none() {
                existing.error_code = new.code.as_ref().map(|c| c.code.clone());
            }
        }
    }

    /// Extract component info from anywhere in the diagnostic
    fn extract_component_info_from_diagnostic(diagnostic: &Diagnostic) -> Option<ComponentInfo> {
        // Try main message
        if let Some(info) = extract_component_info(&diagnostic.message) {
            return Some(info);
        }

        // Try all children
        for child in &diagnostic.children {
            if let Some(info) = extract_component_info(&child.message) {
                return Some(info);
            }
        }

        None
    }

    /// Extract check trait from diagnostic notes
    fn extract_check_trait_from_diagnostic(diagnostic: &Diagnostic) -> Option<String> {
        for child in &diagnostic.children {
            if matches!(child.level, DiagnosticLevel::Note) {
                if let Some(trait_name) = extract_check_trait(&child.message) {
                    return Some(trait_name);
                }
            }
        }
        None
    }

    /// Extract provider relationships from diagnostic notes
    fn extract_provider_relationships_from_diagnostic(
        diagnostic: &Diagnostic,
    ) -> Vec<ProviderRelationship> {
        let mut relationships = Vec::new();

        for child in &diagnostic.children {
            if matches!(child.level, DiagnosticLevel::Note) {
                if let Some(rel) = extract_provider_relationship(&child.message) {
                    relationships.push(rel);
                }
            }
        }

        relationships
    }

    /// Extract delegation chain notes
    fn extract_delegation_notes(diagnostic: &Diagnostic) -> Vec<String> {
        let mut notes = Vec::new();

        for child in &diagnostic.children {
            if matches!(child.level, DiagnosticLevel::Note) {
                if child.message.contains("required for") && child.message.contains("to implement")
                {
                    notes.push(child.message.clone());
                }
            }
        }

        notes
    }

    /// Get all non-suppressed entries
    pub fn get_active_entries(&self) -> Vec<&DiagnosticEntry> {
        self.entries.values().filter(|e| !e.suppressed).collect()
    }

    /// Get all entries (including suppressed)
    pub fn get_all_entries(&self) -> Vec<&DiagnosticEntry> {
        self.entries.values().collect()
    }

    /// Render all CGP error messages as CgpDiagnostic objects
    /// This should be called after all diagnostics have been collected
    /// Returns a vector of CgpDiagnostic objects with improved CGP diagnostics
    pub fn render_cgp_diagnostics(&mut self) -> Vec<CgpDiagnostic> {
        use crate::error_formatting::format_error_message;

        // Get all active (non-suppressed) entries
        let active_entries = self.get_active_entries();

        // Build CgpDiagnostic for each entry
        let mut results = Vec::new();
        for entry in active_entries {
            if let Some(diagnostic) = format_error_message(entry) {
                results.push(diagnostic);
            }
        }

        results
    }

    /// Render all CGP error messages
    /// This should be called after all diagnostics have been collected
    /// Returns a vector of formatted error message strings ready to print
    pub fn render_cgp_errors(&mut self) -> Vec<String> {
        use crate::error_formatting::render_diagnostic_plain;

        self.render_cgp_diagnostics()
            .iter()
            .map(|diag| render_diagnostic_plain(diag))
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_diagnostic_database_basic() {
        let db = DiagnosticDatabase::new();
        assert_eq!(db.get_all_entries().len(), 0);
    }
}
