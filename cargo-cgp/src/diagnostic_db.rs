/// Module for building an internal database of diagnostics and merging related errors
/// This implements the approach described in Chapters 7-8 of the report
use cargo_metadata::diagnostic::{Diagnostic, DiagnosticLevel, DiagnosticSpan};
use cargo_metadata::{CompilerMessage, PackageId, Target};
use std::collections::HashMap;

use crate::cgp_diagnostic::CgpDiagnostic;
use crate::cgp_patterns::{
    ComponentInfo, FieldInfo, ProviderRelationship, extract_check_trait, extract_component_info,
    extract_field_info, extract_provider_relationship, has_other_hasfield_implementations,
};

/// A database that collects and merges related diagnostic information
#[derive(Debug, Default)]
pub struct DiagnosticDatabase {
    /// Map from diagnostic key to merged diagnostic entry
    entries: HashMap<DiagnosticKey, DiagnosticEntry>,
}

/// Key used to identify and group related diagnostics
/// We key only by location to allow merging errors for different components
/// that share the same root cause (e.g., transitive dependencies)
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct DiagnosticKey {
    /// Primary source location (file:line:column)
    /// This is typically the line in check_components! where the error occurs
    location: SourceLocation,
}

/// Source code location
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct SourceLocation {
    file: String,
    line: usize,
    column: usize,
}

impl SourceLocation {
    fn from_span(span: &DiagnosticSpan) -> Self {
        SourceLocation {
            file: span.file_name.clone(),
            line: span.line_start,
            column: span.column_start,
        }
    }
}

/// A merged diagnostic entry combining information from multiple related errors
#[derive(Debug, Clone)]
pub struct DiagnosticEntry {
    /// The original diagnostic (we keep the first one as the primary)
    pub original: Diagnostic,

    /// Package ID from the CompilerMessage
    pub package_id: PackageId,

    /// Target from the CompilerMessage
    pub target: Target,

    /// Extracted field information (missing field errors)
    pub field_info: Option<FieldInfo>,

    /// Component information - supports multiple components at the same location
    /// This allows merging errors for different components that share the same root cause
    pub component_infos: Vec<ComponentInfo>,

    /// Check trait name (from "required by a bound in")
    /// This is the trait generated by check_components!, not the actual consumer trait
    pub check_trait: Option<String>,

    /// Provider relationships extracted from error chain
    pub provider_relationships: Vec<ProviderRelationship>,

    /// Delegation chain notes (raw, for later processing)
    pub delegation_notes: Vec<String>,

    /// Whether this type has other HasField implementations
    pub has_other_hasfield_impls: bool,

    /// Primary spans for error reporting - one span per component
    /// This allows showing multiple components in a merged error message
    pub primary_spans: Vec<DiagnosticSpan>,

    /// Error code (e.g., "E0277")
    pub error_code: Option<String>,

    /// Main error message
    pub message: String,

    /// Whether this is a root cause or a transitive error
    pub is_root_cause: bool,

    /// Whether this error should be suppressed (because it's redundant)
    pub suppressed: bool,
}

impl DiagnosticDatabase {
    pub fn new() -> Self {
        Self::default()
    }

    /// First pass: Add a compiler message to the database
    /// If a related diagnostic already exists, merge information
    /// Diagnostics at the same location are merged to handle transitive dependencies
    /// For check_components! blocks, errors from consecutive lines with the same check_trait are merged
    pub fn add_diagnostic(&mut self, compiler_message: &CompilerMessage) {
        let diagnostic = &compiler_message.message;

        // Extract key components for grouping
        let primary_span = match diagnostic.spans.iter().find(|s| s.is_primary) {
            Some(span) => span,
            None => {
                // Can't process without a location
                return;
            }
        };

        let location = SourceLocation::from_span(primary_span);

        // Build the key using only location
        // But first check if there's an existing entry in the same file with the same check_trait
        // within a few lines (to handle check_components! blocks)
        let check_trait = Self::extract_check_trait_from_diagnostic(diagnostic);
        let mut matched_key = None;

        if let Some(ref trait_name) = check_trait {
            // Look for existing entries with the same check_trait in the same file
            for (existing_key, existing_entry) in &self.entries {
                if let Some(ref existing_trait) = existing_entry.check_trait {
                    // Check if it's the same check trait and in the same file
                    if existing_trait == trait_name && existing_key.location.file == location.file {
                        // Check if they're close together (within 10 lines - typical for check_components! blocks)
                        let line_diff = if existing_key.location.line > location.line {
                            existing_key.location.line - location.line
                        } else {
                            location.line - existing_key.location.line
                        };

                        if line_diff <= 10 {
                            // These are likely in the same check_components! block
                            matched_key = Some(existing_key.clone());
                            break;
                        }
                    }
                }
            }
        }

        if let Some(existing_key) = matched_key {
            // Merge into existing entry
            Self::merge_diagnostic_info(
                &mut self.entries,
                &existing_key,
                diagnostic,
                primary_span.clone(),
            );
        } else {
            // Create new entry with this location as the key
            let key = DiagnosticKey { location };
            let entry = Self::create_entry(
                diagnostic,
                primary_span.clone(),
                compiler_message.package_id.clone(),
                compiler_message.target.clone(),
            );
            self.entries.insert(key, entry);
        }
    }

    /// Creates a new diagnostic entry from a diagnostic
    fn create_entry(
        diagnostic: &Diagnostic,
        primary_span: DiagnosticSpan,
        package_id: PackageId,
        target: Target,
    ) -> DiagnosticEntry {
        // Extract all available information
        let field_info = extract_field_info(diagnostic);
        let component_info = Self::extract_component_info_from_diagnostic(diagnostic);
        let check_trait = Self::extract_check_trait_from_diagnostic(diagnostic);
        let provider_relationships =
            Self::extract_provider_relationships_from_diagnostic(diagnostic);
        let delegation_notes = Self::extract_delegation_notes(diagnostic);
        let has_other_hasfield_impls = has_other_hasfield_implementations(diagnostic);
        let error_code = diagnostic.code.as_ref().map(|c| c.code.clone());

        // Build component_infos vector
        let component_infos = if let Some(info) = component_info {
            vec![info]
        } else {
            vec![]
        };

        // Determine if this is a root cause
        // A root cause has field_info (missing field) or is the most specific error
        let is_root_cause = field_info.is_some();

        DiagnosticEntry {
            original: diagnostic.clone(),
            package_id,
            target,
            field_info,
            component_infos,
            check_trait,
            provider_relationships,
            delegation_notes,
            has_other_hasfield_impls,
            primary_spans: vec![primary_span],
            error_code,
            message: diagnostic.message.clone(),
            is_root_cause,
            suppressed: false,
        }
    }

    /// Merges information from a new diagnostic into an existing entry
    /// This handles the case where multiple components at the same location fail
    /// due to the same root cause (e.g., transitive dependencies)
    fn merge_diagnostic_info(
        entries: &mut HashMap<DiagnosticKey, DiagnosticEntry>,
        key: &DiagnosticKey,
        new: &Diagnostic,
        new_span: DiagnosticSpan,
    ) {
        if let Some(existing) = entries.get_mut(key) {
            // If the new diagnostic has field info and existing doesn't, add it
            if existing.field_info.is_none() {
                if let Some(field_info) = extract_field_info(new) {
                    existing.field_info = Some(field_info);
                    existing.is_root_cause = true;
                }
            }

            // Merge component info - add new component if not already present
            if let Some(new_component_info) = Self::extract_component_info_from_diagnostic(new) {
                // Check if this component is already in the list
                let already_exists = existing
                    .component_infos
                    .iter()
                    .any(|info| info.component_type == new_component_info.component_type);

                if !already_exists {
                    existing.component_infos.push(new_component_info);

                    // Add the new span to the spans list
                    // Check if this span is already present to avoid duplicates
                    let span_exists = existing.primary_spans.iter().any(|span| {
                        span.file_name == new_span.file_name
                            && span.line_start == new_span.line_start
                            && span.column_start == new_span.column_start
                    });

                    if !span_exists {
                        existing.primary_spans.push(new_span);
                    }
                }
            }

            // Merge check trait
            if existing.check_trait.is_none() {
                existing.check_trait = Self::extract_check_trait_from_diagnostic(new);
            }

            // Add new provider relationships
            let new_relationships = Self::extract_provider_relationships_from_diagnostic(new);
            for rel in new_relationships {
                if !existing.provider_relationships.contains(&rel) {
                    existing.provider_relationships.push(rel);
                }
            }

            // Merge delegation notes
            let new_notes = Self::extract_delegation_notes(new);
            for note in new_notes {
                if !existing.delegation_notes.contains(&note) {
                    existing.delegation_notes.push(note);
                }
            }

            // Update hasfield implementations flag
            if !existing.has_other_hasfield_impls {
                existing.has_other_hasfield_impls = has_other_hasfield_implementations(new);
            }

            // If the new diagnostic has an error code and existing doesn't, use it
            if existing.error_code.is_none() {
                existing.error_code = new.code.as_ref().map(|c| c.code.clone());
            }
        }
    }

    /// Extract component info from anywhere in the diagnostic
    fn extract_component_info_from_diagnostic(diagnostic: &Diagnostic) -> Option<ComponentInfo> {
        // Try main message
        if let Some(info) = extract_component_info(&diagnostic.message) {
            // Check if the component_type is truncated (contains "...")
            // If so, try to extract from span text instead
            if !info.component_type.contains("...") {
                return Some(info);
            }
        }

        // Try all children
        for child in &diagnostic.children {
            if let Some(info) = extract_component_info(&child.message) {
                if !info.component_type.contains("...") {
                    return Some(info);
                }
            }
        }

        // If message-based extraction failed or returned truncated result,
        // try to extract component name from the span text
        if let Some(span) = diagnostic.spans.iter().find(|s| s.is_primary) {
            if let Some(info) = Self::extract_component_info_from_span(span) {
                return Some(info);
            }
        }

        None
    }

    /// Extract component info from the span's source text
    /// This is used as a fallback when the compiler truncates type names in error messages
    fn extract_component_info_from_span(span: &DiagnosticSpan) -> Option<ComponentInfo> {
        // Concatenate all text lines from the span
        let span_text: String = span
            .text
            .iter()
            .map(|line| line.text.as_str())
            .collect::<Vec<_>>()
            .join("\n");

        // Extract component name from the span text
        // The highlighted portion should contain something like "AreaCalculatorComponent"
        extract_component_info(&span_text)
    }

    /// Extract check trait from diagnostic notes
    fn extract_check_trait_from_diagnostic(diagnostic: &Diagnostic) -> Option<String> {
        for child in &diagnostic.children {
            if matches!(child.level, DiagnosticLevel::Note) {
                if let Some(trait_name) = extract_check_trait(&child.message) {
                    return Some(trait_name);
                }
            }
        }
        None
    }

    /// Extract provider relationships from diagnostic notes
    fn extract_provider_relationships_from_diagnostic(
        diagnostic: &Diagnostic,
    ) -> Vec<ProviderRelationship> {
        let mut relationships = Vec::new();

        for child in &diagnostic.children {
            if matches!(child.level, DiagnosticLevel::Note) {
                if let Some(rel) = extract_provider_relationship(&child.message) {
                    relationships.push(rel);
                }
            }
        }

        relationships
    }

    /// Extract delegation chain notes
    fn extract_delegation_notes(diagnostic: &Diagnostic) -> Vec<String> {
        let mut notes = Vec::new();

        for child in &diagnostic.children {
            if matches!(child.level, DiagnosticLevel::Note) {
                if child.message.contains("required for") && child.message.contains("to implement")
                {
                    notes.push(child.message.clone());
                }
            }
        }

        notes
    }

    /// Get all non-suppressed entries
    pub fn get_active_entries(&self) -> Vec<&DiagnosticEntry> {
        self.entries.values().filter(|e| !e.suppressed).collect()
    }

    /// Get all entries (including suppressed)
    pub fn get_all_entries(&self) -> Vec<&DiagnosticEntry> {
        self.entries.values().collect()
    }

    /// Render all CGP error messages as CgpDiagnostic objects
    /// This should be called after all diagnostics have been collected
    /// Returns a vector of CgpDiagnostic objects with improved CGP diagnostics
    pub fn render_cgp_diagnostics(&mut self) -> Vec<CgpDiagnostic> {
        use crate::error_formatting::format_error_message;

        // Get all active (non-suppressed) entries
        let active_entries = self.get_active_entries();

        // Build CgpDiagnostic for each entry
        let mut results = Vec::new();
        for entry in active_entries {
            if let Some(diagnostic) = format_error_message(entry) {
                results.push(diagnostic);
            }
        }

        results
    }

    /// Render all CGP error messages
    /// This should be called after all diagnostics have been collected
    /// Returns a vector of formatted error message strings ready to print
    pub fn render_cgp_errors(&mut self) -> Vec<String> {
        use crate::error_formatting::render_diagnostic_plain;

        self.render_cgp_diagnostics()
            .iter()
            .map(|diag| render_diagnostic_plain(diag))
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_diagnostic_database_basic() {
        let db = DiagnosticDatabase::new();
        assert_eq!(db.get_all_entries().len(), 0);
    }
}
